{"componentChunkName":"component---src-templates-blog-post-js","path":"/GraphQL/graphql/","result":{"data":{"site":{"siteMetadata":{"title":"Tech Notes and some other stuff"}},"markdownRemark":{"id":"be4715ed-d826-5e1c-9a9f-eacdde431773","excerpt":"What is GraphQL?\nA layer between the front end client and backend data base.\nIf there are multiple data servers (eg: mongo, db2, sql), the client has to talk…","html":"<p><strong>What is GraphQL?</strong>\nA layer between the front end client and backend data base.\nIf there are multiple data servers (eg: mongo, db2, sql), the client has to talk only to GraphQL\nGraphQL clients are in control of the data they need. They will request fr the data that they need (APIs return all the data where as graphQL\nreturn only necessary data, no overfetching)\neg: query from the client requesting for particular fields:\n{\nemplyee(id: 42) {\nfirstName\nlastName\nemail\n}\n}\nsample resposne (a JSON object)\n{\n“employee”: {\n“firstName”: “Joe”,\n“lastName: “Mathew”,\n“email”:“jmp@gmail.com”\n}\n}\nAs we can see, the answer matches the request query. Every field in the query, becomes a key in the answer object.</p>\n<p>GraphQL has to parts to it:</p>\n<ul>\n<li>Its a query language</li>\n<li>It a run time as well</li>\n</ul>\n<p>Query language - Its all about the communication or the query language. Query (read operation) and Mutation (Write operation)\nRun time - This is about validation of the queries, the type system, Introspection and Execution</p>\n<p>Clients can perform query / mutation operation using a medium like HTTP.</p>\n<p>A <strong>GraphQL document</strong> can containe one more more operations.</p>\n<p>GraphQL run time - Reads and translates GraphQL docuemntats to other data services and vice versa while handling the response.\nAlso, GraphQL run time defines a graph based schema to declare teh GraphQL API service capabilties to all clients. </p>\n<p><strong>GraphQL schema</strong>\nEvery field we define in a schema has a type. (scalar or non scalar)\nEvery field has a resolver function to read the logic.</p>\n<p>Client sends a GraphQL request\nThe GraphQL server read the input from an interface\nFind the resolver function for each fields\nThe response might be a field having another resolver function\nIf so, process that resolver as well\nConsolidate the resposne and send to client</p>\n<p>GraphQL query language is very similar to JSON.</p>\n<p><strong>GraphQL Editor</strong></p>\n<p>There are many GraphQL demo sites available eg: GraphQLHub.com\nThere are many projects under GraphQLHub.com. Any of the projects under this\nif clicked will open in an (in browser) editor called GraphiQL (an editor from facebook).</p>\n<p><strong>GraphQL Language syntax</strong>\n<em>query operation</em>\nexample:\nquery QueryName {\ngraphQLHub\ngithub {\nuser(username: “deepaannjohn”) {\nlogin\nid\ncompany\navatar_url\nrepos {\nname\n}\n}\n}\n}</p>\n<p>tip: use ctrl+space to get prompts inside GraphiQL editor\ntype String! => this field is mandatory</p>\n<p><strong>GraphQL Query language</strong>\n<strong>Fields</strong>\nScalar fields\nThey are simple fields (primitive / basic)\nexamples:\nGraphQLInt\nGraphQLFloat\nGraphQLString\nGraphQLBoolean\nGraphQLID - special type of id  which appears in all GraphQL responses</p>\n<p>Complex fields\nThey usually have a custom type (eg: GutHubUser having name, companyname etc)\nAnother example:\nGraphQLList</p>\n<p>GraphQL fields are modelled after functions. They accept argumets and return something in response.\nOn the server, we write JS functions to determine the value returned by every field.\nThese functions are called resolver functions.</p>\n<p>In the above github query example, th use field accepted username and used\nresolver function to determine the value to  be returned.</p>\n<p>Variables\nusage: to make query reusable\nexample:\nquery ($reponame: String!){\ngithub {\nrepo (name : $reponame, ownerUsername: “facebook”)  {\ncommits {\nmessage\ndate\n}\n}\n}\n}</p>\n<p>Directives\nDirectives are used to alter the graphQL run time and they are used along with variables to achieve this.\nexamples of Built in directives are\na. @skip\nb. @include</p>\n<p>Directive also support arguments, just like fields.\neg: @skip, @include accepts a variable if (which is a boolean)</p>\n<p>Directives can be used with fields and fragments</p>\n<p>eg:\nquery test($includerepos: Boolean!) {\ngithub {\nuser (username: “deepaannjohn”) {\nlogin,\nrepos @include(if: $includerepos) {\nname\n}\n}\n}\n}</p>\n<p>Aliases\neg:\nA UI componenet is expecting user.githubid as ‘id’ where as the JSON response object from\nGraphQL has ‘id’ in the response.</p>\n<p>We can rename as below:\nrequest:\nquery test {\ngithub {\nuser (username: “deepaannjohn”) {\nlogin,\ngithubid : id\n}\n}\n}\nresponse:\n{\n“data”: {\n“github”: {\n“user”: {\n“login”: “deepaannjohn”,\n“githubid”: 1234\n}\n}\n}\n}</p>\n<p>So UI component can use it as response.data.github.githubid.\nAgain, this gives clients more control.</p>\n<p>another use of alias:\nto retrieve the same field more than once\nquery test {\ngithub {\nuser1: user(username: “deepaannjohn”) {\nlogin\ngithubid: id\n}\nuser2: user(username: “mathewjpallan”) {\nlogin\nid\n}\n}\n}</p>\n<p>reponse:\n{\n“data”: {\n“github”: {\n“user1”: {\n“login”: “deepaannjohn”,\n“githubid”: 1234\n},\n“user2”: {\n“login”: “mathewjpallan”,\n“id”: 5678\n}\n}\n}\n}</p>\n<p>Fragments\nFragments make GraphQL composable\nusage: to eliminate repeatition\neg:\nquery test {\ngithub {\nuser1: user(username: “deepaannjohn”) {\n…UserInfoFragment\n}\nuser2: user(username: “mathewjpallan”) {\n…UserInfoFragment\n}\n}\n}</p>\n<p>fragment UserInfoFragment on GithubUser {\nlogin,\nid\n}</p>\n<p>… => spread operator</p>\n<p>Mutations\nWriting into GraphQL</p>\n<p>eg:\nmutation m1($inputval: SetValueForKeyInput!) {\nkeyValue_setValue(input: $inputval) {\nitem {\nid\nvalue\n}\nclientMutationId\n}\n}</p>\n<p>{\n“inputval”: {\n“id”: “1”,\n“value”: “3635”,\n“clientMutationId”: “3”</p>\n<p>  }\n}</p>\n<p><strong>GraphQL Runtime</strong>\nWhat we saw above was how to access GraphQL APIs.\nNow the next part is to build the GraphQL APIs / server.</p>\n<p>eg:\na hello-world graphql application:\nrequest:\n{\nhello\n}\nexpected response:\n{\n“data”:{\n“hello”:“world”\n}\n}</p>\n<p>We need to define the schema first.\nTo do that we can use npm graphql pacakge.</p>\n<p>graphql npm package provides two important capabilities: building a type schema, and serving queries against that type schema.</p>\n<p>graphql-helloworld (without http server) is avaialble here:\n<a href=\"https://github.com/deepaannjohn/graphql-helloworld\">https://github.com/deepaannjohn/graphql-helloworld</a></p>\n<p>graphql-http-endpoint (with http server endpoint) is available here:\n<a href=\"https://github.com/deepaannjohn/graphql-http-endpoint\">https://github.com/deepaannjohn/graphql-http-endpoint</a></p>","frontmatter":{"title":"Getting started with GraphQL","date":"January 20, 2020","description":"Some basic inforamtion to get started with GraphQL"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/GraphQL/graphql/","previous":{"fields":{"slug":"/gatsby/gatsby/"},"frontmatter":{"title":"Getting started with GatsbyJS"}},"next":{"fields":{"slug":"/flutter/flutter/"},"frontmatter":{"title":"Getting started with mobile app devlopment using Flutter"}}}}}